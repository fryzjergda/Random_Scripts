#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import shutil
import argparse
from argparse import RawTextHelpFormatter
import os  
from textwrap import wrap
import csv
import subprocess
import zipfile


import pandas as pd
import glob

def argument_parser():

    parser = argparse.ArgumentParser(description=__doc__, prog='fpocketR_parser', formatter_class=RawTextHelpFormatter)
    parser.add_argument("-f", "--file", required=True, dest="file",
                            help="Input pdb file.")

    args = parser.parse_args() 

    infile = args.file

    return infile

def find_conda():
    # First try to get the path from the CONDA_EXE environment variable
    conda_path = os.environ.get('CONDA_EXE')
    if conda_path and os.path.isfile(conda_path):
        return conda_path

    # If not found, check if 'conda' is available in the system's PATH
    conda_path = shutil.which('conda')
    if conda_path:
        return conda_path

    # As a last resort, check common installation paths (can add more as needed)
    common_paths = [
        '/usr/local/miniconda3/bin/conda', 
        '/usr/local/anaconda3/bin/conda',
        '/opt/conda/bin/conda',
        '/miniconda3/bin/conda',
        '/anaconda3/bin/conda'
    ]
    for path in common_paths:
        if os.path.isfile(path):
            return path

    # Return None if no Conda executable found
    return None


def run_fpocketR(inpdb):

    #conda_executable = "/path/to/conda"  # Adjust this path as necessary

    conda_executable = find_conda()
    if conda_executable:
        print(f"Conda found at: {conda_executable}")

    conda_env = 'fpocketR'
    #activate_command = f'{conda_executable} init && {conda_executable} activate {conda_env}'
    #subprocess.run(activate_command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)

    fpocket_command = f'{conda_executable} run -n {conda_env} python -m fpocketR -pdb {inpdb} --ligand noll --offset 0 -o fpocket-R'

    # Combine commands to activate conda and run fpocketR in one call
    combined_command = f'{fpocket_command}'
    
    try:
        # Execute the command
        result = subprocess.run(combined_command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        print("fpocketR output:", result.stdout)
        print("fpocketR errors:", result.stderr)
    except subprocess.CalledProcessError as e:
        print("An error occurred while running fpocketR:", e)
        return

def get_best_pockets(target_dir):
    if not os.path.isdir(target_dir):
        print(f"Directory does not exist: {target_dir}")
        return

    # Navigate to the target directory
    os.chdir(target_dir)
    
    # Find the CSV file with characteristics in its name
    csv_files = glob.glob('*characteristics.csv')
    if not csv_files:
        print("No characteristics CSV file found.")
        return
    csv_file = csv_files[0]  # Assuming there's only one such file

    # Read the CSV file
    df = pd.read_csv(csv_file)
    
    # Extract relevant columns
    relevant_data = df[['Pocket', 'Score', 'Drug score', 'SASA', 'Volume']]
    
        # Find the desired metrics
    pockets = {
        'score': relevant_data.loc[relevant_data['Score'].idxmax()]['Pocket'],
        'drug_score': relevant_data.loc[relevant_data['Drug score'].idxmax()]['Pocket'],
        'sasa': relevant_data.loc[relevant_data['SASA'].idxmax()]['Pocket'],
        'volume': relevant_data.loc[relevant_data['Volume'].idxmax()]['Pocket']
    }
    
    os.chdir("./pockets")
    results = {}
    
    for metric, pocket in pockets.items():
        pocket_file = f"pocket{int(pocket)}_vert.pqr"
        if os.path.exists(pocket_file):
            df_pocket = parse_pqr(pocket_file)
            # Format DataFrame before saving
            median_df = format_dataframe(df_pocket.median().to_frame().T)
            mean_df = format_dataframe(df_pocket.mean().to_frame().T)
            results[metric] = {
                'median': median_df,
                'mean': mean_df
            }
            # Save to CSV with metric names
            median_df.to_csv(f"{metric}_median.csv", index=False)
            mean_df.to_csv(f"{metric}_mean.csv", index=False)

    return results

def format_dataframe(df):
    # Format floating point numbers to three decimal places and ensure pocket number is an integer
    df['pocket_number'] = df['pocket_number'].astype(int)  # Ensure the 'Pocket' column is treated as integers
    for column in df.select_dtypes(include=['float64']).columns:
        df[column] = df[column].apply(lambda x: f"{x:.3f}")
    return df

def parse_pqr(file_path):
    data = []
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith('ATOM'):
                parts = line.split()
                x, y, z = float(parts[5]), float(parts[6]), float(parts[7])
                pocket_number = int(parts[4])
                data.append([pocket_number, x, y, z])
    return pd.DataFrame(data, columns=['pocket_number', 'x', 'y', 'z'])


def move_and_compress_files(base_dir):
    # Define the pattern to search for directories
    print(os.system("pwd"))
  
    
    source_dir_pattern = os.path.join(base_dir, '*_clean_out', 'pockets')
    source_dirs = glob.glob(source_dir_pattern)
    
    if not source_dirs:
        print(f"No directories found matching pattern: {source_dir_pattern}")
        return
    source_dir = source_dirs[0]  # Assume the first match is the correct one
    
    print(f"Found directory: {source_dir}")

    # Move CSV files to the current working directory
    csv_files = glob.glob(os.path.join(source_dir, '*.csv'))
    print(f"Found CSV files: {csv_files}")
    
    for file in csv_files:
        shutil.move(file, os.getcwd())  # Move each file to the current working directory
        print(f"Moved {file} to {os.getcwd()}")
    
    # Compress the 'fpocket-R' directory into a zip file
    zip_file = f"{base_dir}.zip"
    with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(base_dir):
            for file in files:
                file_path = os.path.join(root, file)
                arcname = os.path.relpath(file_path, os.path.join(base_dir, '..'))
                zipf.write(file_path, arcname)
    
    # Remove the 'fpocket-R' directory after compression
    shutil.rmtree(base_dir)
    print(f"Removed directory {base_dir}")


    
if __name__ == '__main__':
    
    main_dir = os.getcwd()
    print(main_dir)

    infile = argument_parser()
    
    name = ''.join(infile.split(".")[:-1])
    
    run_fpocketR(infile)

    char_dir = f"fpocket-R/{name}_clean_out"

    best_pockets_results = get_best_pockets(char_dir)

    print(best_pockets_results)
    
    base_directory = "./fpocket-R"
    os.chdir(main_dir)
    move_and_compress_files(base_directory)


    
    